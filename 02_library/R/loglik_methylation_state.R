#' Support for methylation status
#'
#' `loglik_methylation_state` calculates log likelihood that a
#' region of DNA is unmethylated, methylated in CG only, or methylated in CG,
#' CHG and CHH contexts (TE-like methylation).
#'
#' This first estimates the true mean methylation level (theta) for each context
#' given conversion-rate-error point estimates.
#' Because conversion errors really follow a distribution the correction is not
#' perfect, and residual erroneous methylation persists which tends to inflate
#' TE-like and CG methylation.
#' Therefore, a threshold is set giving the maximum level of apparent
#' methylation expected in unmethylated DNA, and the function calculates the
#' probability that theta is above or below this threshold.
#' It uses this to calculate the likelihood of observing the data given theta,
#' and given that theta is equal to zero, and uses this to get likelihoods that
#' the feature is unmethylated (all thetas are zero), CG-methylated (theta>0 for
#' CG, zero for CHG and CHH), or TE-methylated (all thetas > 0).
#'
#' Note thatwhen there is no coverage at both log likelihoods are NA.
#' As a workaround, these are set to 0 so ratios can be calculated.
#' This is not ideal, but shouldn't bias inference because we are really
#' comparing support between two models.
#' When both are equal we can't tell them apart.
#' In reality this usually happens when coverage is very low, and it would be
#' sensible to set a lower bound on coverage.
#'
#' @param read_counts Dataframe of read counts over one or more feaures with
#' columns `id` (feature name), `context` (sequence context: `CG`, `CHG`, `CHH`,
#' `total`), `meth` (integer counts of methylated reads mapping in each context,
#' ), `unmethylated` (integer counts of un methylated reads mapping in each
#' context).
#' @param lambda1 Float between 0 and 1 giving the probability that an
#' unmethylated read is appears methylated
#' @param lambda2 Float between 0 and 1 giving the probability that a methylated
#' read is appears unmethylated
#' @param threshold Float between 0.002 and 0.998 to set the threshold
#' delimiting methylated and unmethylated DNA.
#' @param return_probabilities If TRUE, AICs are normalised to sum to one.
#' @return Dataframe giving feature ID, coverage, AIC values that each
#' fearture is unmethylated, CG methylated or TE methylated, and a categorical
#' call on methylation status based on which hypothesis has the lowest AIC.
#' @seealso mlbinom_with_errors, llbinom_with_errors
#' @author  Tom Ellis
loglik_methylation_state <- function(read_counts, lambda1, lambda2, threshold, return_probabilities=FALSE){

  # Total coverage
  read_counts$n <- read_counts$meth + read_counts$unmethylated

  # Mean methylation, correcting for errors
  read_counts$theta <- mlbinom_with_errors(
    y=read_counts$meth, n=read_counts$n, lambda1, lambda2
  )

  # Log likelihoods that mean methylation is below or above a threshold
  # For each row in read_counts: take read counts and calculate the likelihood
  # they were generated by means in a series of from 0.001 to 0.999
  # Returns a matrix with a column for each row in read_counts and a row for
  # likelihoods below and above the threshold.
  theta_vals <- seq(0.001, 0.999, 0.001)
  ll_below_above_threshold <- sapply(1:nrow(read_counts), function(i) {
    ll_vector <- llbinom_with_errors(
      y=read_counts$meth[i], n=read_counts$n[i], p=theta_vals, lambda1=lambda1, lambda2=lambda2
    )
    ll_vector <- ll_vector - logsumexp(ll_vector)
    c(
      logsumexp(ll_vector[theta_vals < threshold]),
      logsumexp(ll_vector[theta_vals >= threshold])
    )
  }
  )
  read_counts$ll_zero <- ll_below_above_threshold[1,]
  read_counts$ll_theta <- ll_below_above_threshold[2,]

  # Log likelihoods that theta > 0 and theta = 0
  read_counts$ll_theta = llbinom_with_errors(
    y=read_counts$meth, n=read_counts$n, p=read_counts$theta, lambda1, lambda2
  )
  read_counts$ll_zero = llbinom_with_errors(
    y=read_counts$meth, n=read_counts$n, p=0, lambda1, lambda2
  )

  # If methylation is 100%, change log likelihood from NaN to 0
  # read_counts$ll_theta = ifelse(read_counts$theta == 1, 0, read_counts$ll_theta)
  # If there is no coverage at all, return likelihoods of zero
  read_counts$ll_theta = ifelse(read_counts$n == 0, 0, read_counts$ll_theta)
  read_counts$ll_zero  = ifelse(read_counts$n == 0, 0, read_counts$ll_zero)

  # Log likelihoods that each feature is unmethylated
  ll_unmethylated = read_counts$ll_zero[ read_counts$context == "CG" ] +
    read_counts$ll_zero[ read_counts$context == "CHG" ] +
    read_counts$ll_zero[ read_counts$context == "CHH" ]
  # Log likelihoods that each feature is CG methylated
  ll_CG = read_counts$ll_theta[ read_counts$context == "CG" ] +
    read_counts$ll_zero[ read_counts$context == "CHG" ] +
    read_counts$ll_zero[ read_counts$context == "CHH" ]
  # Log likelihoods that each feature is TE-like methylated
  ll_te_like = read_counts$ll_theta[ read_counts$context == "CG" ] +
    read_counts$ll_theta[ read_counts$context == "CHG" ] +
    read_counts$ll_theta[ read_counts$context == "CHH" ]

  # Return a dataframe giving feature ID, coverage, and loglikelihoods
  output <- data.frame(
    id = unique(read_counts$id),
    n  = read_counts$n[read_counts$context == "total"],
    unmethylated = ll_unmethylated,
    mCG = ll_CG ,
    te_like = ll_te_like
  )
  # Make a call on methylation status at each feature
  output$state <- ifelse(output$n > 0, "unmethylated", NA)
  output$state <- ifelse(
    (output$mCG - output$unmethylated) > 3, "mCG", output$state
  )
  output$state <- ifelse(
    (output$te_like - output$mCG) > 3, "te_like", output$state
  )

  # Normalise log likelihoods values to sum to one within rows.
  if(return_probabilities){
    aic_sum <- apply(output[, c('unmethylated', 'mCG', 'te_like')], 1, logsumexp)
    output$unmethylated <- exp(output$unmethylated - aic_sum)
    output$mCG <- exp(output$mCG - aic_sum)
    output$te_like <- exp(output$te_like - aic_sum)
  }


  # # Return a dataframe giving feature ID, coverage, and loglikelihoods
  # output <- data.frame(
  #   id = unique(read_counts$id),
  #   n  = read_counts$n[read_counts$context == "total"],
  #   unmethylated = -2*(ll_unmethylated),
  #   mCG = 2 - 2* (ll_CG) ,
  #   te_like = 6 - 2* (ll_te_like)
  # )
  #
  # # Make a call on methylation status at each feature
  # output$state <- ifelse(output$n > 0, "unmethylated", NA)
  # output$state <- ifelse(
  #   (output$unmethylated - output$mCG) > 0, "mCG", output$state
  # )
  # output$state <- ifelse(
  #   (output$mCG - output$te_like) > 0, "te_like", output$state
  # )

  # # Normalise AIC values to sum to one within rows.
  # if(return_probabilities){
  #   aic_sum <- rowSums(exp(-output[, c('unmethylated', 'mCG', 'te_like')]))
  #   output$unmethylated <- exp(-output$unmethylated) / aic_sum
  #   output$mCG <- exp(-output$mCG) / aic_sum
  #   output$te_like <- exp(-output$te_like) / aic_sum
  # }


  output
  }
